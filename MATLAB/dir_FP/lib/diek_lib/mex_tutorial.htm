<html><head><title>Is there a Tutorial for Creating MEX-files with Emphasis on C MEX-files?</title></head><body bgcolor="#efefef">
<h1>
<b>
<a name="RTFToC1">1615
Is there a Tutorial for Creating MEX-files with Emphasis on C MEX-files?
</a></b>
</h1>

<i>Revision 1.0</i><br>
<hr noshade="noshade" size="2">
<p>


</p><h2>
<b>
<a name="RTFToC2">Introduction</a></b>
</h2>

<p>
This tutorial provides a general overview of MEX-files and a detailed
explanation of the external interface functions that allow you to interface C
or Fortran subroutines to MATLAB.  It includes C MEX-file code examples that
demonstrate the use of the external interface functions.
</p><p>

</p><p>
MEX stands for <b>M</b>ATLAB <b>Ex</b>ecutable.  MEX-files are dynamically
linked subroutines produced from C or Fortran source code that, when compiled,
can be run from within MATLAB in the same way as MATLAB M-files or built-in
functions.  The external interface functions provide functionality to transfer
data between MEX-files and MATLAB, and the ability to call MATLAB functions
from C or Fortran code.
</p><p>

</p><p>
MATLAB for Windows supports two formats for MEX-files: REX (<b>R</b>elocatable
<b>Ex</b>ecutable) format and DLL (<b>D</b>ynamic <b>L</b>ink <b>L</b>ibrary)
format.  
</p><p>

</p><p>
The REX format uses 32-bit code, thus yielding performance comparable to
MATLAB's built-in functions.  REX-format MEX-files are recommended for
numerically intensive applications.
</p><p>

</p><p>
The DLL format (which is 16-bit code) yields slower performance and
necessitates the use of huge pointers to deal with matrices larger then 64k.
The advantages of using a DLL format is that it allows you to access the
functions in the Windows environment (i.e., to create custom user interfaces
for your applications).
</p><p>


</p><h2>
<b>
<a name="RTFToC3">Why
Use MEX-files?
</a></b><br>

<b></b>
</h2>
There are several situations where you might want to use a MEX-file:
<p>

</p><ul>
<li>MEX-files interface large pre-existing C or Fortran code with MATLAB
without rewriting the code in MATLAB.

</li><li>The algorithm to be implemented contains some <tt>for</tt> and
<tt>while</tt> loops that can not be vectorized.  MATLAB may not process loops
as quickly as C or Fortran code.  MEX-file loops run at normal C or Fortran
code speed, resulting in a substantial performance increase. 
</li></ul>

<ul>
<li>To access hardware.  For example, MEX-files can be used to access A/D and
D/A boards.

</li><li>In MATLAB for Windows, custom Windows user interfaces can be created.
</li></ul>

<p>


</p><h2>
<b>
<a name="RTFToC4">Components
of MEX-files
</a></b>
</h2>

<p>
There are a number of issues that need to be understood in order to write your
own C MEX-files.
</p><p>
 
</p><ul>
<li>The source code for a MEX-file consists of:


<p>
<i>Computational routine</i>  -  which contains the actual code that you want
implemented in the MEX-file. It is called by the gateway routine (for short
MEX-files, the computational routine code can be included in the gateway).
</p><p>

</p><p>
<i>Gateway routine</i>  - which interfaces the computational routine with
MATLAB: It calls the computational routine.
</p><p>


</p></li><li>All C MEX-file source code must contain the statement
</li></ul>

<ul><ul><pre>#include "mex.h"</pre></ul></ul><br>
<tt></tt>
<ul>
so that the entry point and the interface routines are declared properly
(Fortran does not include this file).
</ul>

<ul>
<li>The entry point to the gateway routine must be named <tt>mexFunction</tt>.
This function acts similarly to the function <tt>main()</tt> in a standalone C
program, in that it is where the function MEX-file starts executing when MATLAB
calls it.  <tt>mexFunction</tt> has four input arguments, and must be
prototyped in one of two ways, depending on if the compiler is ANSI C
compatible.  For example:
</li></ul>

<ul>
ANSI (standard C):
<ul><ul><pre>void mexFunction(int nlhs,
                 Matrix *plhs[],
                 int nrhs,
                 Matrix *prhs[])</pre></ul></ul><br>

</ul>
<tt></tt>
<ul>
Non-ANSI (Traditional C, Original C, old C, K&amp;R C):
<ul><ul><pre>mexFunction(nlhs, plhs, nrhs, prhs)
int nlhs, nrhs;
Matrix *plhs[], *prhs[];</pre></ul></ul><br>

</ul>
<tt></tt>
<p>
<tt></tt>

</p><h4>
<b><i>
<a name="RTFToC5">Example
of the World's Smallest MEX-file
</a></i></b>
<ul><pre>
/* The following is the world's smallest MEX-file that
   actually does something.  
   Note that it is written in ANSI C.
*/

#include "mex.h"

void mexFunction(int nlhs,
                 Matrix *plhs[],
                 int nrhs,
                 Matrix *prhs[])
     {
     mexPrintf("Hello world");
     }</pre></ul><br>

</h4>

<p>
<code>mexPrintf(format,...)</code> is, for the most part, just like C's
<code>printf</code> function.  See the FAQ at the end of this document for
exceptions.  <code>format </code>is a format-specifier string, which can be
followed by some arguments.  <code>mexPrintf </code>uses the format-specifier
string to print the arguments (or the contents of the arguments, if they are
variables) to the MATLAB command window.  For example,
</p><p>

</p><ul><pre>mexPrintf("This is an integer: %d.",5);</pre></ul><br>

<p>
would print 
</p><p>

</p><ul><pre>This is an integer: 5.</pre></ul><br>


<h2>
<b>
<a name="RTFToC6">MATLAB
Variables (Matrices)
</a></b>
</h2>

<p>
Before we can discuss the inputs and outputs of MEX-files, we need to
understand what a MATLAB variable is.
</p><p>

</p><p>
Each MATLAB variable is a matrix (even strings and scalars are considered to be
matrices).  A matrix is the C-language definition of a MATLAB variable.  It is
a structure containing the following information:
</p><p>

</p><ul>
Matrix's name (<tt>name</tt>)<br>
Matrix's dimensions (<tt>m</tt> and <tt>n</tt>)<br>
Arrays of the matrix's real and imaginary parts (<tt>pr</tt> and
<tt>pi</tt>)<br>
If sparse, arrays describing the matrix's structure (<tt>ir, jc, nzmax</tt>)<br>

</ul>
For a full (nonsparse) matrix, <tt>pr</tt> and <tt>pi</tt> are one-dimensional
arrays of doubles.  The data in the matrix is stored in these arrays
columnwise, the same way that Fortran stores its two-dimensional arrays (this
is because MATLAB was originally written in Fortran).  For example, 
<p>

</p><ul><pre>&gt;&gt;A =
   1.0000 + 1.0000i   2.0000             3.0000          
   4.0000             5.0000 + 1.0000i   6.0000          </pre></ul><br>
<tt></tt>
<p>
<tt></tt>would be stored in the matrix (or C structure) as 
</p><p>
<tt></tt>
</p><ul><pre>Matrix.name     ="A"
Matrix.m        = 2
Matrix.n        = 3
Matrix.pr[0]    = 1.0     Matrix.pi[0]  = 1.0
Matrix.pr[1]    = 4.0     Matrix.pi[1]  = 0.0
Matrix.pr[2]    = 2.0     Matrix.pi[2]  = 0.0
Matrix.pr[3]    = 5.0     Matrix.pi[3]  = 1.0
Matrix.pr[4]    = 3.0     Matrix.pi[4]  = 0.0
Matrix.pr[5]    = 6.0     Matrix.pi[5]  = 0.0
</pre></ul><br>
Note that if a matrix is purely real (all imaginary elements are zero), then
the <tt>pi</tt> pointer equals <tt>NULL</tt>.  
<p>

</p><p>
The structure of sparse matrices is not dealt with in this tutorial.  However,
it's described in the Sparse Matrices section of this document.
</p><p>

</p><p>
</p><h2>Inputs and Outputs of MEX-files</h2>
<p>

</p><p>
Inputs
</p><ul>
<li><tt>nrhs</tt>:  number of right-hand side arguments
</li><li><tt>prhs</tt>:  pointer to right-hand side arguments
</li></ul>

<p>
Outputs
</p><ul>
<li><tt>nlhs:</tt>  number of left-hand side arguments
</li><li><tt>plhs:</tt>  pointer to left-hand side arguments
</li></ul>

<p>
The variables <tt>nlhs </tt>and <tt>nrhs</tt> specify the number of left-hand
and right-hand side arguments that are used when the MEX-file is called.  They
are analogous to the MATLAB variables<tt> nargout</tt> and <tt>nargin</tt>,
respectively.  For example, if the MEX-file was called in MATLAB using
</p><p>

</p><ul><pre>[a,b]=mymexfunction(d,e,f)</pre></ul><br>

<p>
then<tt> nlhs</tt> equals 2 (for <tt>a</tt> and <tt>b</tt>), and <tt>nrhs</tt>
equals 3 (for <tt>d</tt>, <tt>e</tt>, and <tt>f</tt>).
</p><p>

</p><p>
<tt>prhs</tt> is an array of pointers to the input matrices.  Thus, in the
above example,<tt> plhs[0]</tt> is a pointer to the matrix <tt>d</tt>, and<tt>
prhs[1]</tt> is a pointer to the matrix <tt>e</tt>.<tt> plhs</tt> is an
uninitialized array.  If <tt>plhs</tt> is greater than zero, then the MEX-file
should fill the <tt>plhs</tt> array with pointers to matrices containing valid
data, or generate an error message stating that too many outputs were requested.
</p><p>


</p><h2>
<b>	
<center><img src="mex_tutorial_files/00c1f.gif"></center></b>
</h2>

<p>

</p><p>
The MEX External Interface provides several functions that allow you to
determine various states of a matrix.  These functions are used to check the
input to the MEX-file to make sure it's what's expected.  The functions that
have the prefix mxIs are:
</p><p>

</p><p>
<tt></tt>

</p><center><pre>i = mxIsComplex(mp)                   i = 1 if pi&lt;&gt;NULL, 0 otherwise        
i = mxIsFull(mp)                      i = 1 if matrix is Full, 0 if         
                                      matrix is sparse                      
i = mxIsSparse(mp)                    i = 1 if matrix is Sparse, 0 if       
                                      matrix is Full                        
i = mxIsNumeric(mp)                   i = 1 if matrix is numeric, 0 if      
                                      matrix is a string                    
i = mxIsString(mp)                    i = 1 if matrix is a string, 0 if     
                                      matrix is numeric                     
i = mxIsDouble(mp)                    i = This is for future                
                                      compatibility, in case matrices       
                                      ever contain non-double elements.     

</pre></center>

<p>

</p><p>

</p><p>
In order to prevent passing inputs that are the incorrect type, use the
<tt>mxIs*</tt> functions extensively at the beginning of your MEX-file.  For
example, suppose <tt>prhs[0]</tt> is supposed to be a regular, full,
real-valued matrix.  To prevent passing your function a sparse matrix, a string
matrix, or a complex matrix, use code similar to the following:
</p><ul><pre>
if ( mxIsComplex(prhs[0]) || mxIsSparse(prhs[0]) || \\
     mxIsString(prhs[0]) )
     mexErrMsgTxt("first input must be real, full, \\
     and nonstring");</pre></ul><br>

<p>
Putting these checks in prevents your MEX-file from crashing, for no apparent
reason, when you accidentally pass it the wrong type of data. 
</p><p>


</p><h3>
<b><i>
<a name="RTFToC7">Example:
MEX-file Checking Inputs and Outputs
</a></i></b>
<ul><pre>
/* The following is a very basic MEX-file that checks to 
   make sure that its input is a scalar.  Note that it
   is written in ANSI C.                 */

#include "mex.h"

void mexFunction (int nlhs,
                  Matrix *plhs[],
                  int nrhs,
                  Matrix *prhs[]);





{
  int m, n;
  double x, *y;

  /* check: only one input and one output argument */ 
  if (prhs != 1)
    mexErrMsgTxt("Must have one input argument");
  if (prhs != 1)
    mexErrMsgTxt("Must have one output argument");

/* prevent you from passing a sparse matrix, a string 
   matrix, or a complex matrix */
if ( mxIsComplex(prhs[0]) || mxIsSparse(prhs[0]) || \\
     mxIsString(prhs[0]) )
  mexErrMsgTxt("Input must be real, full, and \\
                nonstring");
}
</pre></ul><br>

</h3>
The function <tt>mexErrMsgTxt </tt>works like the MATLAB function
<tt>error.</tt>  When called, it exits the MEX-file, and reports an error
message specified in the input string.
<p>

</p><p>
The MEX-file example first checks to make sure that the function was called
correctly, with the correct number of inputs and outputs.  It verifies that the
input is a scalar.  Then, using the<tt> mxIs*</tt> functions, it verifies that
the input is a full nonsparse matrix.  Finally, it gets the pointer to the real
part of the output matrix and fills in its first element with the function's
output.
</p><p>


</p><h2>
<b>
<a name="RTFToC8">Allocating
Matrix Structures 
</a></b>
</h2>

<p>
The MEX External Interface provides three functions to create matrices to be
passed to MATLAB.
</p><p>

</p><ul>
<li><tt>mxCreateFull </tt>
</li><li><tt></tt><tt>mxCreateSparse </tt>
</li><li><tt></tt><tt>mxCreateString </tt>
</li></ul>
<tt></tt>
<p>
<tt></tt>To clear the matrix structure defined by the above functions use:
</p><p>

</p><ul><pre> mxFreeMatrix</pre></ul><br>


<h3>
<b><i>
<a name="RTFToC9">Creating
Matrices:
</a></i></b><br>

<b><i></i></b>
</h3>
The following variable declarations will be used:
<p>


</p><center>
<table border="1" cellpadding="1" cellspacing="1">
<tbody><tr>
<td>str</td><td>is of type char *</td>      
</tr>
<tr>
<td>mp</td><td>is of type Matrix *</td>   
</tr><tr>    
<td>x</td><td>is of type double</td>      
</tr><tr>              
<td> xp</td><td>is of type double *</td>
</tr>
<tr><td>i</td><td>is of type int</td>      
</tr><tr>
<td>ip</td><td>is of type int *</td>
</tr>
<tr><td>nzmax</td><td>is of type int</td>
</tr></tbody></table>
</center>

<p>

</p><p>
<tt>mp=mxCreateFull(m,n,complex_flag)</tt> allocates memory for a new full
<tt>m</tt> by<tt> n</tt> matrix.  <tt>complex_flag</tt> is <tt>REAL</tt> for a
real matrix, and <tt>COMPLEX</tt> for an imaginary/complex matrix. 
</p><p>

</p><p>
<tt>mp=mxCreateSparse(m,n,nzmax,complex_flag)</tt> allocates memory for a new
sparse <tt>m</tt> by <tt>n</tt> matrix.  <tt>Nzmax</tt> is the maximum number
of nonzero elements in the sparse matrix.  <tt>complex_flag</tt> is as above.
</p><p>

</p><p>
<tt>mp=mxCreateString(str)</tt> allocates a string matrix and copies the
contents of <tt>str</tt> into it.
</p><p>

</p><p>
<tt>mxFreeMatrix(mp)</tt> frees (destroys) a full or sparse matrix.
</p><p>


</p><h3>
<b><i>
<a name="RTFToC10">Accessing
String and Scalar  Matrices:
</a></i></b>
</h3>

<p>
<tt>errcode=mxGetString(mp,str,strlen)</tt> copies up to <tt>strlen</tt>
characters out of the matrix <tt>mp</tt> into the character buffer pointed to
by <tt>str. str</tt> must be preallocated either statically or via<tt>
mxCalloc.</tt>  <tt>Errcode</tt> is 0 for success, 1 if <tt>mp</tt> is not a
string matrix or length of <tt>mp</tt> is greater than <tt>strlen.</tt>
</p><p>

</p><p>
<tt>x=mxGetScalar(mp)</tt> returns the (1,1) element (of the MATLAB matrix) of
the matrix <tt>mp.</tt>
</p><p>


</p><h3>
<b><i>
<a name="RTFToC11">Allocating/Deallocating
Memory:
</a></i></b>
</h3>

<p>
<tt>voidptr=mxCalloc(n,size)</tt> - is similar to the C <tt>calloc</tt>
function, but allocates memory from the MATLAB heap.  <tt>n</tt> is the number
of elements to allocate;<tt> size</tt> is the size of each element.
</p><p>

</p><p>
<tt>mxFree(voidptr)</tt> - is similar to the C<tt> free</tt> function.  It
frees/deallocates memory allocated with <tt>mxCalloc.</tt>
</p><p>


</p><h2>
<b>
<a name="RTFToC12">Accessing
Individual Members of Matrix Structures
</a></b>
</h2>

<p>
These functions provide access to the individual matrix structure members.


<center>
</center><table border="0" cellpadding="0" cellspacing="9">
<tbody><tr>
<th>Matrix member</th><th>Type</th><th>To read from Matrix</th><th>To write to Matrix</th>
</tr><tr>      
<td><tt>name</tt></td><td><tt>char *</tt></td><td><tt>str = mxGetName(mp)</tt></td><td><tt>mxSetName(mp,str)</tt></td>       
</tr><tr>
<td><tt>m</tt></td><td><tt>int</tt></td><td><tt>i = mxGetM(mp)</tt></td><td><tt>mxSetM(mp,i)</tt></td>            
</tr><tr>
<td><tt>n</tt></td><td><tt>int</tt></td><td><tt>i = mxGetN(mp)</tt></td><td><tt>mxSetN(mp,i)</tt></td>           
</tr><tr>
<td><tt>pr</tt></td><td><tt>double *</tt></td><td><tt>xp = mxGetPr(mp)</tt></td><td><tt>mxSetPr(mp,xp)</tt></td>   </tr><tr>      
<td><tt>pi</tt></td><td><tt>double *</tt></td><td><tt>xp = mxGetPi(mp)</tt></td><td><tt>mxSetPi(mp,xp)</tt></td>   </tr><tr>       
<td><tt>ir</tt></td><td><tt>int *</tt></td><td><tt>ip = mxGetIr(mp)</tt></td><td><tt>mxSetIr(mp,ip)</tt></td>       </tr><tr>   
<td><tt>jc</tt></td><td><tt>int *</tt></td><td><tt>ip = mxGetJc(mp)</tt></td><td><tt>mxSetJc(mp,ip)</tt></td>      </tr><tr>   
<td><tt>nzmax</tt></td><td><tt>int</tt></td><td><tt>I = mxGetNzmax(mp)</tt></td><td><tt>mxSetNzmax(mp,i)</tt></td> 
</tr></tbody></table>



</p><p>
Where <tt>mp </tt>represents type <tt>Matrix *</tt>
</p><p>

</p><p>
With the matrix access routines provided by The MathWorks, it is not necessary
to know the actual structure of a matrix.  The matrix access functions, which
all begin with the sentinel characters <tt>mx</tt>, provide access to the
matrix, which allows for future changes in the structure of the matrix without
having to rewrite MEX-code.
</p><p>

</p><p>
Note that the <tt>mxSet*</tt> commands are "dumb."  That is, if you set one
part of the matrix using an <tt>mxSet*</tt> function, then it is up to you to
make sure the rest of the matrix contents are consistent.  For example, if you
set<tt> m</tt> and<tt> n</tt> to be 3 and 2, it is up to you to make sure
<tt>pr</tt> and<tt> pi</tt> are six element arrays of doubles.
</p><p>


</p><h3>
<b><i>
<a name="RTFToC13">Example:
MEX-file Accepts One Input and Returns One Output
</a></i></b>
<ul><pre>
/* The following is a very basic MEX-file that returns
   the input value plus 1. Note that it is written in
   ANSI C.
*/

#include "mex.h"

void mexFunction(int nlhs, 
                 Matrix *plhs[],
                 int nrhs, 
                 Matrix *prhs[])
{
int m, n;
double x, *y;

 m = mxGetM(prhs[0]); /* get the dimensions of the 
                         input */
 n = mxGetN(prhs[0]);

/* make sure input is 1x1 */
  if (m*n != 1) 
  mexErrMsgTxt("Input must be a scalar");

/* Create/allocate return argument, a 1x1 real-valued
   Matrix */
  plhs[0]=mxCreateFull(1,1,REAL); 

/* Get pointer to real part of return argument */
  y = mxGetPr(plhs[0]);  

  x = mxGetScalar(prhs[0]);  /* Get value of input */<br>
  y[0] = x + 1; /* assign a value to return argument */
}</pre></ul><br>

</h3>


<h3>
<b><i>
<a name="RTFToC14">
Registering an Exit Function
</a></i></b>
</h3>

<p>
Another advantage of MEX-files is that they can have static memory.  This means
that variables inside the MEX-file that are declared static retain their values
from call to call of the MEX-file.  Any initialization of these variables
occurs when the function is called for the first time, i.e. when the function
is loaded into memory.  
</p><p>

</p><p>
Certain events can cause MATLAB to remove the MEX-file from memory.  Some
examples of these events are:
</p><p>

</p><ul>
<li>You execute <tt>clear</tt>, <tt>clear</tt> <tt>all</tt>, <tt>clear
mex</tt>, or <tt>clear &lt;mexfunction&gt;.</tt>
</li><li>You issue the <tt>pack</tt> command.
</li><li>MATLAB needs to free up some memory for a new variable.	
</li><li>MATLAB is terminated.

</li></ul>
When MATLAB removes a MEX-file that contains a static variable from memory, the
static variable is lost.  The next time the MEX-file is called, it loads into
memory again, and all static variables are reinitialized to their original
value.  Therefore, there needs to be a way to warn you and the MEX-files that
it is being unloaded, so that it can clean up any data structures it maintains,
and save any important data it has. This is accomplished with an exit function.

<p>

</p><p>
An exit function is called by MATLAB just before it unloads its corresponding
MEX-file.  Each MEX-file is allowed to have its own exit function, but no
MEX-file can have more than one exit function.  The MEX-file registers its exit
function by calling the<tt> mexAtExit</tt> function.  The exit function must
return a void, and cannot accept any input arguments.  
</p><p>

</p><p>
This example shows an exit function, as well as the corresponding call to
<tt>mexAtExit</tt>, registering the exit function:
</p><p>

</p><ul><pre>void myExitFcn() {
      mexPrintf("Warning, MEX-file is being unloaded");
}

/* Later on, inside the mexFunction ... */
if mexAtExit(myExitFcn)
       mexPrintf("Error, myExitFcn not registered //
properly");
</pre></ul><br>


<h2>
<b>
<a name="RTFToC15">Data
Transfer: MEX-files &lt;==&gt; MATLAB
</a></b>
</h2>

<p>
These functions allow you to pass matrices to and get matrices from MATLAB.
</p><p>


</p><center><pre>Get Matrices from MATLAB                 Put Matrices in MATLAB                   
mexGetMatrix *                           mexPutMatrix *                           
mexGetFull *                             mexPutFull **                            
mexGetMatrixPtr*                                                                  

</pre></center>

<ul><pre>*  To clear use mxFreeMatrix
**  To clear use mxFree
</pre></ul><br>


<h3>
<b><i>
<a name="RTFToC16">Passing
Matrices Between MEX-files and MATLAB
</a></i></b>
</h3>

<p>
Usually, matrices are passed to MATLAB via the right-hand side (rhs) and the
left-hand side (lhs) method.  This means that variables are passed into and out
of a function by being included as arguments to the function. Sometimes, there
are cases in which you may need to violate this standard.  Some examples are:
</p><p>

</p><ul>
<li>You have more than 50 input or output variables (MATLAB has a limit of 50)

</li><li>You want to modify many variables using a function, and you don't want to
have to type
<pre>
[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,...] = func(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,...)
</pre><br>

</li></ul>
Unlike function M-files, MEX functions have the unique ability to get matrices
from the workspace of the calling function, without having the matrix passed in
via the <tt>prhs</tt> structure.  The "calling function" is the M-file function
from which the MEX-file is called.  When a MEX-file is called from an M-file
script or the command line, the calling function's workspace is the main MATLAB
workspace.  For example, assume you call the following function:
<p>

</p><ul><pre>function thefun
x=5; y=0;
themexfun(x);</pre></ul><br>

<p>
Even though <tt>themexfun</tt> is only passed the variable <tt>x</tt>, it can
still gain access to the variable <tt>y</tt>.  The following code fragment
shows one way this can be done from inside the MEX-file (assuming <tt>mp</tt>
is a <tt>Matrix *):</tt>
</p><p>

</p><ul><pre>Matrix *mp;
mp = mexGetMatrix("y");</pre></ul><br>

<p>
When this code is executed, a copy of the variable <tt>y </tt>is made, and
<tt>mp</tt> is assigned to point to it.  Because a copy of the variable is
made, you must remember to free <tt>mp</tt> with <tt>mxFreeMatrix </tt>when you
are done with it.
</p><p>

</p><p>
The following examples describe the three <tt>mexGet*</tt> functions that can
access a matrix in more detail.  The examples use these variable declarations:
</p><p>

</p><ul><pre>Matrix *mp;
int m,n, errcode;
double *pr, *pi;
char *name;</pre></ul><br>

<p>

</p><ol>
<b></b><li><b>Example of using <tt>mexGetMatrix</tt>()</b>

<b>	</b>
<p>
	<tt>mp=mexGetMatrix(name)</tt> - Make a copy of the matrix whose name is
specified by <tt>name</tt> from the calling function's workspace.  Return a
pointer to the copy, or <tt>NULL</tt> if the matrix doesn't exist.  Remember to
free <tt>mp</tt> with <tt>mxFreeMatrix.</tt>
</p><p>
	
</p><ul><pre>Matrix *mymatrix;

if ((mymatrix = mexGetMatrix("a"))==NULL)
mexErrMsgTxt("Variable 'a' does not exist in workspace.");
else {
&lt;do stuff with mymatrix&gt;
mxFreeMatrix(mymatrix);
}
</pre></ul><br>
<tt>	</tt>
<p>
	

<b></b></p></li><li><b><tt></tt>Example of using <tt>mexGetFull()</tt></b><tt></tt>

<tt>	</tt>
<p>
	<tt>errcode=mexGetFull(name,&amp;m,&amp;n,&amp;pr,&amp;pi)</tt> - Similar to
<tt>mexGetMatrix,</tt> but instead of returning a matrix pointer, the various
elements of the matrix are copied directly into <tt>m, n, pr</tt>, and
<tt>pi.</tt>  Note that you do not need to allocate memory for <tt>pr</tt>
and<tt> pi,</tt> because <tt>mexGetFull</tt> does this for you.  But, you do
need to free <tt>pr</tt> and <tt>pi</tt> with <tt>mxFree</tt> when you are done
with them.  As its name implies, this function can only be used with full
matrices, not sparse ones. <tt> Errcode</tt> is 0 if successful, 1 if the
matrix doesn't exist.
</p><ul><pre>	
int m,n;
double pr[], pi[];

if mexGetFull("a",&amp;m, &amp;n, &amp;pr, &amp;pi)
mexErrMsgTxt("Variable 'a' does not exist in workspace.");
else {
&lt;do stuff with m, n, pr, pi&gt;
mxFree(pr);
mxFree(pi);
}
</pre></ul><br>
<tt>	</tt>
<p>
<b></b></p></li><li><b>Example of using <tt>mexGetMatrixPtr()</tt></b>
</li></ol>
<p>
</p><ul><p>
<tt>mp=mexGetMatrixPtr(name)</tt> - Again, similar to <tt>mexGetMatrix</tt>,
but instead of making a copy of the matrix, a pointer to the original matrix is
returned.  The only thing you should do with <tt>mp</tt> is change the data in
the matrix or use its contents for calculations.  
</p><p>

</p><p>
Do not  change the dimensions, sparsity, or complexity of the matrix.
</p><p>

</p><ul><pre>Matrix *mymatrix;

if ((mymatrix = mexGetMatrixPtr("a"))==NULL)
mexErrMsgTxt("Variable 'a' does not exist in workspace.");
else {
     &lt;do stuff with mymatrix&gt;
     }</pre></ul></ul><br>

<p>

</p><p>
MEX-files can also place variables into the calling function's workspace.  When
doing this, if a variable with the same name already exists in the calling
function's it is deleted and replaced with the new variable.  Otherwise, the
variable is simply placed into the workspace.  For example, suppose this code
appeared in the MEX-file <tt>themexfun:</tt>
</p><p>
<tt></tt>
</p><ul><pre>Matrix *mp;

mp=mxCreateString("Hi there");
mxSetName(mp,"A");
mexPutMatrix(mp);</pre></ul><br>

<p>
Assume that before running <tt>themexfun</tt>, there were no variables in the
current workspace.  After running <tt>themexfun</tt>, there would be a variable
named <tt>A</tt> in the current workspace, containing the string<tt> Hi
there.</tt>
</p><p>

</p><p>
The following describes the two functions that allow for putting matrices into
a workspace.  The same declarations as above are used here:
</p><p>

</p><p>
<tt>errcode=mexPutMatrix(mp)</tt> - Put a copy of the matrix pointed to by
<tt>mp</tt> into the calling function's workspace.  If a variable with the same
name already exists there, it is replaced.  <tt>errcode</tt> is 0 for success
and 1 if an error occurred.
</p><p>

</p><p>
<tt>errcode=mexPutFull(name,m,n,pr,pi)</tt> - Similar to <tt>mexPutMatrix,</tt>
but rather than taking a pointer to a matrix as input, the various parts of a
full matrix are passed to it instead.  This function allocates a matrix of size
<tt>m </tt>by <tt>n</tt>, copies the data from <tt>pr</tt> and <tt>pi</tt> to
it, and gives it the name specified by <tt>name</tt>.  It then passes the
matrix to the calling function's workspace in the same way as
<tt>mexPutMatrix</tt>.  As with <tt>mexPutMatrix</tt>, errcode is 0 for success
and 1 if an error occurred.
</p><p>

</p><p>
In general, use caution when using any of the <tt>mexGet*</tt> or
<tt>mexPut*</tt> functions.  These functions, especially the <tt>mexPut*</tt>
functions, are likely to have strange side effects, which at best create
strange variables in your workspace, and at worst write over your data without
you knowing about it.  These effects are documented in the function's on-line
help.
</p><p>

</p><p>


</p><h2>
<b>
<a name="RTFToC17">Calling
MATLAB Functions From MEX-files
</a></b>
</h2>

<p>
The next two functions allow you to call other MATLAB functions.
</p><p>

</p><ul><pre>*  mexEvalString
*  mexCallMATLAB
</pre></ul><br>


<h3>
<b><i>
<a name="RTFToC18">Calling
Another Function from a MEX-file Using mexEvalString
</a></i></b>
</h3>

<p>
<tt>errcode=mexEvalString(str)</tt> - Similar to MATLAB's <tt>eval</tt>
function, this function evaluates its string input in the calling function's
workspace, in the same manner as if it had been entered at the MATLAB command
line.  For example, 
</p><p>

</p><ul><pre>mexEvalString("p=plot(1:10);");</pre></ul><br>

<p>
would generate a plot of 1 to 10 in the current figure window.  Note that since
the command is evaluated in the calling function's workspace, the variable
<tt>p</tt> is stored in the calling function's workspace.  Thus, if the
MEX-file were to be called from within an M-file function, <tt>p</tt> would be
stored in that function's workspace, not the main workspace.
</p><p>

</p><p>
Although <tt>mexEvalString</tt> is easy to code, the string passed to
<tt>mexEvalString</tt> is evaluated by MATLAB, therefore, the MATLAB parser has
to be called.  Calling another MEX-file via the <tt>mexEvalString</tt> is not
very efficient since the MATLAB parser is called.  Also, all variables created
by the <tt>mexEvalString</tt> command are stored in the workspace of the
function text called by the MEX-file, which may need to be retrieved with the
<tt>mexGet*</tt> functions.  A more efficient way to accomplish the same goal
is to use the <tt>mexCallMATLAB</tt> function (assuming you're calling a
function and not a script).
</p><p>


</p><h3>
<b><i>
<a name="RTFToC19">Calling
Another Function from a MEX-file Using mexCallMATLAB
</a></i></b>
</h3>

<p>
Other MATLAB functions, including built-in functions, MEX-file and M-file
functions, (not M-file scripts) can be called from within a MEX-file using the
<tt>mexCallMATLAB</tt> function.  
</p><p>

</p><p>
This function accepts five inputs.  The first four are structured exactly the
same as the inputs to <tt>mexFunction </tt>which are <tt>nlhs,plhs,nrhs</tt>,
and <tt>prhs</tt>, are int's, and <tt>plhs</tt> and <tt>prhs</tt> are pointers
to arrays of matrices.  You set up <tt>nrhs, prhs</tt>, and <tt>nlhs</tt> to
contain what you want passed to the MATLAB function that you are calling. The
function returns any output data in <tt>plhs</tt>.  Thus, it is as if your
MEX-file is acting as the MATLAB parser, arranging the data in the correct data
structure and passing it to the function.  The fifth argument is a character
string containing the name of the MATLAB function to be called.  The following
is an example of this that calculates the determinant of a matrix and prints it
out.  The example assumes the matrix pointer <tt>mp</tt> has already been
initialized to contain valid data:
</p><ul><pre>
int nlhs1, nrhs1;  /* chances are plhs and prhs are
                      already used by mexFunction */

Matrix *plhs1[1], *prhs1[1];

prhs1 = 1;         /* One output requested from the
                      'det' function */
prhs1 = 1;         /* One input passed to the 'det'
                      function */

prhs1[0] = mp;     /* Set up input argument to 'det' */

mexCallMATLAB(nlhs1,plhs1,nrhs1,prhs1,"det");
mexPrintf("Det(mp) == %g",mxGetScalar(plhs1[0]));
mxFreeMatrix(plhs1[0]);
</pre></ul><br>

<p>
There are three things to note here.  
</p><p>

</p><ol>
<li>Any variable created by the MATLAB function and returned (by
<tt>mexCallMATLAB)</tt> in the <tt>plhs</tt> data structure must be freed by
your MEX-file when you are done with it.  
<p>

</p><p>
</p></li><li>Even if a function is called with <tt>nlhs</tt> equal to zero (no output
arguments requested), it can still return up to one matrix.  This matrix is
assigned to the built-in variable <tt>ans</tt> if the function is called from
the command line.  Therefore, even if you set <tt>nlhs</tt> to zero when
calling <tt>mexCallMATLAB</tt>, you should still make sure that <tt>plhs</tt>
contains space for at least one output matrix, and you should never pass
<tt>NULL</tt> for <tt>plhs</tt>.  <tt>*plhs</tt> is an array of matrix
pointers.  If<tt> nlhs == 0</tt> this means<tt> plhs[0] == NULL</tt> and not
<tt>plhs</tt> <tt>== NULL</tt>.  Therefore, the correct syntax to assign
<tt>plhs</tt> when there are no output arguments is: 
<p>

</p><ul>
<tt>plhs[0] = NULL;</tt>
</ul>

<p>
</p></li><li>You can access MATLAB's operators, such as <tt>*</tt> (multiplication) and
<tt>/ </tt>(division), by specifying the operator in string form as the fifth
input to <tt>mexCallMATLAB.  </tt>
<p>
</p></li></ol>
<p>
<tt></tt>The following is a list of all the valid operators that can be used
with the <tt>mexCallMATLAB</tt> function:
</p><p>


</p><center>
<table border="2" width="50%">
<tbody><tr>
<td>=</td><td>|</td><td>&amp;</td></tr><tr>
<td>:</td><td>&gt;</td><td>&gt;=</td></tr><tr>
<td>&lt;</td><td>&lt;=</td><td>==</td></tr><tr>
<td>~=</td><td>-</td><td>~</td></tr><tr>
<td>+</td><td>*</td><td>/</td></tr><tr>
<td>\ </td><td>.*</td><td>./</td>
</tr><tr>
<td>.\ </td><td>^</td><td>.^</td></tr><tr>
<td>' </td><td>'</td><td><br></td>                                     
</tr></tbody></table>
</center>

<p>

</p><p>
Thus, to add two matrices together, you could make the following call (assuming
<tt>prhs</tt> already contains the two matrices):
</p><p>

</p><ul><pre>mexCallMATLAB(1,plhs,2,prhs,"+");</pre></ul><br>

<p>
Ordinarily, if an error occurs in the function call made by
<tt>mexCallMATLAB</tt>, MATLAB prints the appropriate error message and returns
to the command prompt.  However, by using the <tt>mexSetTrapFlag</tt> function,
you can change this behavior.  Calling <tt>mexSetTrapFlag</tt>(<tt>1</tt>) will
set the trap flag so that if an error occurs, <tt>mexCallMATLAB</tt> will
return control to the MEX-file.  <tt>mexCallMATLAB</tt> will then return an
integer error code of zero if the function call was successful, and nonzero if
an error occurred.  Calling <tt>mexSetTrapFlag</tt>(<tt>0</tt>) returns
<tt>mexCallMATLAB</tt> to its default behavior.
</p><p>
 

</p><h2>
<b>
<a name="RTFToC20">Sparse
Matrices
</a></b>
</h2>

<p>
The best way to explain how sparse matrices are stored in matrix structures is
through an example.
</p><p>

</p><p>
Given a 4-by-4 full matrix <tt>A:</tt>
</p><ul><pre>
&gt;&gt;A =   [0 0 0 1
         0 5 0 0
         0 0 7 6
         0 9 8 0]</pre></ul><br>

<p>
and converting it to a sparse matrix results in the following sparse matrix
characteristics:
</p><p>

</p><ul><pre>nzmax = 6     % maximum number of non-zero elements
    m = 4     % number of rows
    n = 4     % number of columns
</pre></ul><br>
This sparse matrix will be stored in memory in the following manner:
<p>

</p><p>
<tt>pr</tt> is a pointer of type double
</p><p>
<tt>ir</tt> and <tt>jc</tt> are arrays of type integers
</p><p>

</p><p>


</p><center>
<table border="1" width="60%">
<tbody><tr>
<td> <tt>pr</tt> ---&gt;</td><td>5.0</td><td>9.0</td><td>7.0</td><td>8.0</td><td>1.0</td><td>6.0</td><td><tt>pr</tt> has <tt>nzmax</tt><br>elements;contains<br>doubles</td>          
</tr></tbody></table>
</center>

<p>


</p><center>
<table border="1" width="60%">
<tbody><tr>
<td> <tt>ir</tt> ---&gt;</td><td>1</td><td>3</td><td>2</td><td>3</td><td>0</td><td>2</td><td><tt>ir</tt> has <tt>nzmax</tt><br>elements; contains<br>integers</td>         
</tr></tbody></table>
</center>

<p>


</p><center>
<table border="1" width="60%">
<tbody><tr>
<td> <tt>jc</tt> ---&gt;</td><td>0</td><td>0</td><td>2</td><td>4</td><td>6</td><td><tt>jc</tt> has <tt>n+1</tt> elements;<br><tt>n</tt>=number of columns;<br>contains integers</td>       
</tr></tbody></table>
</center>

<p>

</p><p>

</p><p>

</p><p>
<b>Note</b>: Indexing off of 0 (not 1) will be used to reference elements of
the <tt>pr</tt>, <tt>ir</tt>, and <tt>jc</tt> arrays and also of the matrix
<tt>A</tt>.
</p><p>

</p><p>
Each element in the <tt>ir</tt> array indicates in which row (of the <tt>A</tt>
matrix) the corresponding value (using same index as in <tt>ir</tt>) in
<tt>pr</tt> is located.
</p><p>

</p><p>
For example, the first element (the zero'th index) in the <tt>ir</tt> array is
1, thus the corresponding element (zero'th index of <tt>pr</tt>) in <tt>pr</tt>
is in  row 1 of array <tt>A</tt> (indexing <tt>A</tt> off of zero).  Here's a
table of the first few elements:
</p><p>


</p><center>
<table border="1" cellpadding="1" cellspacing="1">
<tbody><tr>
<td>matrix<br>property</td><td>index</td><td>value</td><td>Explanation</td>    </tr><tr>
<td><tt>ir</tt><br><tt>pr</tt></td><td>0<br>0</td><td>1<br>5.0</td><td>therefore, in row 1 of <tt>A</tt> you'll find 5.0</td>    
</tr><tr>
<td><tt> ir</tt><br> <tt>pr</tt></td><td>1<br> 1</td><td>3<br> 9.0</td><td>therefore, in row 3 of <tt>A</tt> you'll find 9.0</td>    
</tr><tr>
<td><tt>ir</tt><br> <tt>pr</tt></td><td>2<br> 2</td><td>2<br> 7.0</td><td>therefore, in row 2 of <tt>A</tt> you'll find 7.0</td>    
</tr></tbody></table>
</center>

<p>
The <tt>jc</tt> array is a little more tricky. If you traverse the <tt>A</tt>
matrix (indexing off of 0) in a column order and you only count the nonzero
elements, it results in the following vector of nonzero elements:
</p><p>




</p><center>
<table border="1" cellpadding="10" cellspacing="2" width="60%">  
<tbody><tr>
<td> nonzero values:</td><td>5</td><td>9</td><td>7</td><td>8</td><td>1</td><td>6</td>
</tr></tbody></table>
</center>
<center>
<table border="0" cellpadding="13" cellspacing="2" width="60%">
<tbody><tr>
<td>-----------------&gt; </td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
</tr><tr>
<td></td><td colspan="6">(indexing this vector off of 0)</td></tr></tbody></table></center>
                           
<p>

</p><p>
By looking back at the <tt>A</tt> matrix you see that the values 5, 7 and 1 are
the first nonzero occurrences in each row.  These values correspond to the
indices 0, 2, and 4 of the vector created of all the nonzero elements of the
<tt>A</tt> matrix.
</p><p>

</p><p>
The <tt>jc</tt> array is made up of indices of the first nonzero element for
each column of the <tt>A</tt> matrix. <tt>jc</tt> arrray always starts with 0;
whether it is because the 1st column of <tt>A</tt> contains all zeros or
because the 1st non-zero element of the 1st column of <tt>A</tt> is in the 0th
index of <tt>pr</tt>. The second entry of the <tt>jc</tt> array is the number
of non-zero elements prior to the second column of the matrix <tt>A</tt>  and
the third and the fourth entries are the number of non-zero elements prior to
the third and fourth columns, respectively.  This paradigm can be followed for
larger sparse matrices.  The final value of the <tt>jc</tt> array is the actual
number of the non-zero elements in the matrix; thus, for matrix <tt>A</tt>, it
is 6.  Therefore, the <tt>jc</tt> array is:
</p><p>

</p><p>


</p><center>
<table border="1" width="60%">
<tbody><tr>
<td><tt>jc</tt> ---&gt;</td><td>0</td><td>0</td><td>2</td><td>4</td><td>6</td>         
</tr></tbody></table>
</center>

<p>


</p><h2>
<b>
<a name="RTFToC21">Summary
of Terms and Acronyms
</a></b>
</h2>


<center>
<table border="1" cellpadding="1" cellspacing="1" width="85%">
<tbody><tr>
<th colspan="2" align="left"><i> Calling Function's</i></th>

</tr><tr>
<td>Workspace</td>
<td>The workspace of the function that calls the MEX-file.
<br>If the MEX-file is called from a script or from the MATLAB command line, 
this is the main MATLAB workspace</td>

</tr><tr>
<td>Exit function</td><td>Function called before a MEX-file is deallocated.</td>
</tr><tr>
<td>MEX</td><td>abbreviation for <b>M</b>ATLAB <b>Ex</b>ecutable. See MEX-file.</td>
</tr><tr>
<td>MEX-file</td> 
<td>A file containing a compiled MEX-file or C Fortran code function. 
<br>When it is compiled, it can be run from within      
<br> MATLAB in the same way as an M-file function.</td>                 
</tr><tr>
<td>Matrix</td>    
<td>The C-language representation of a MATLAB variable.</td>
</tr><tr>
<td>Matrix Access<br>Routines</td> 
<td>functions that provide access to the parts of a matrix 
<br>structure</td>                              
</tr><tr>
<td>Trap Flag</td>          
<td> If this flag is true, <tt>mexCallMATLAB</tt> returns control to the    
<br>MEX-file after an error.  If false, <tt>mexCallMATLAB</tt> returns     
<br>to the MATLAB command prompt</td>                                  
</tr></tbody></table>
</center>

<p>
</p><center>
<table border="1" cellpadding="4" cellspacing="1" width="85%">
<tbody><tr><th colspan="2" align="left"><i>mexFunction Input and Output Argument List</i></th> 
</tr><tr>
<td><tt>nlhs</tt></td><td>Number of left-hand side (output) arguments from a MEX-file.</td>
</tr><tr>           
<td><tt>nrhs</tt></td><td>Number of right-hand side (input) arguments to a MEX-file.</td>             
</tr><tr>
<td><tt>plhs</tt></td><td>Array of pointers to left-hand side arguments for a MEX-file.</td>
</tr><tr>          
<td><tt>prhs</tt></td><td>Array of pointers to right-hand side arguments for a MEX-file.</td>        
</tr></tbody></table>
</center>


<h2>
<b>
<a name="RTFToC22">List
of External Interface functions
</a></b>
</h2>


<center>
<table border="1" cellpadding="1" cellspacing="1" width="85%">

<tbody><tr><th colspan="2" align="left"><i>mex* Routine</i></th>                                                                      
</tr><tr>
<td><tt> mexAtExit</tt></td><td>Function to register a MEX-file's exit function.</td>      
</tr><tr>
<td><tt>mexCallMATLAB</tt></td><td>Function to call a MATLAB function from within a      <br>  MEX-file.</td>
</tr><tr>                                             
<td><tt>mexErrMsgTxt</tt></td><td>Function that reports an error in a MEX-file.</td>
</tr><tr>
<td><tt>mexEvalString</tt></td><td>Function that evaluates a string using the MATLAB
                          <br> parser.</td>                                               
</tr><tr>
<td><tt>mexFunction</tt></td><td>Function that is called first when a MEX-file is                          <br>called from MATLAB.</td>
</tr><tr>
<td><tt>mexGetFull</tt></td><td>Function to get the information in a matrix from      
                            the calling function's workspace.</td>                     
</tr><tr>
<td><tt>mexGetMatrix</tt></td><td>Function to get a matrix from the calling             
                      <br>function's workspace.</td>

</tr><tr>
<td><tt>mexGetMatrixPtr</tt></td><td>Function to get a pointer to a matrix in the                               <br>calling function's workspace.</td>
</tr><tr>
<td><tt>mexPrintf</tt></td><td>Function to print to the MATLAB command window.</td>       
</tr><tr>
<td><tt>mexPutFull</tt></td><td>Function to put matrix information into a matrix,     
                   <br>which is then placed into the calling function's      
                   <br>workspace.</td>                                            
</tr><tr>
<td><tt>mexPutMatrix</tt></td><td>Function to put a matrix into the calling             
                     <br>function's workspace.                                 
</td></tr><tr>
<td><tt>mexSetTrapFlag</tt></td><td>Function to set <tt>mexCallMATLAB's</tt> trap flag.</td>      </tr></tbody></table>      
</center>

<p>
</p><center>
<table border="1" cellpadding="1" cellspacing="1" width="85%">
<tbody><tr><th colspan="2" align="left"><i>mx* Routines</i></th>                                                                      
</tr><tr>
<td><tt>mxCalloc</tt></td><td>Function to allocate a block of memory dynamically.</td>     
</tr><tr>
<td><tt>mxCreateFull</tt></td><td>Function to allocate a new full matrix dynamically.</td>     
</tr><tr>
<td><tt>mxCreateSparse</tt></td><td>Function to allocate a new sparse matrix dynamically.</td>
</tr><tr>   
<td><tt>mxCreateString</tt></td><td>Function that allocates a new string matrix and                            <br>copies a C string into it.</td>
</tr><tr>
<td><tt>mxFree</tt></td><td>Function to free memory allocated with mxCalloc.</td>        
</tr><tr>
<td><tt>mxFreeMatrix</tt></td><td>Function to free a dynamically allocated matrix.</td>        
</tr><tr>
<td><tt>mxGetIr</tt></td><td>Function to get the pointer to the <tt>ir</tt> vector of a       
                 <br>sparse matrix.</td>                                          
</tr><tr>
<td><tt>mxGetJc</tt></td><td>Function to get the pointer to the <tt>jc</tt> vector of a       
                <br>sparse matrix.</td>                                          
</tr><tr>
<td><tt>mxGet</tt></td><td>Function to get the number of rows of a matrix.</td>         
</tr><tr>
<td><tt>mxGetN</tt></td><td>Function to get the number of columns of a matrix.</td>      
</tr><tr>
<td><tt>mxGetName</tt></td><td>Function to get the name of a matrix.</td>                   
</tr><tr>
<td><tt>mxGetNzmax</tt></td><td>Function to get the maximum number of nonzero           
                    <br>elements in a sparse matrix.</td>                            
</tr><tr>
<td><tt>mxGetPi</tt></td><td>Function to get the pointer to the imaginary part of    
                 <br>a matrix.</td>                                               
</tr><tr>
<td><tt>mxGetPr</tt></td><td>Function to get the pointer to the real part of a       
                 <br>matrix.</td>                                                 
</tr><tr>
<td><tt>mxGetScalar</tt></td><td>Function which returns the (1,1) element of a matrix.   </td>

</tr><tr>
<td><tt>mxGetString</tt></td><td>Function which copies a string matrix into a C string. </td>
</tr><tr> 
<td><tt>mxIsComplex</tt></td><td>Function which returns true for complex matrices.</td>       
</tr><tr>
<td><tt>mxIsDouble</tt></td><td>Function that returns true if a matrix contains         
                  <br>double precision elements.</td>                              
</tr><tr>
<td><tt>mxIsFull</tt></td><td>Function that returns true for full (nonsparse)         
                 <br>matrices.</td>                                               
</tr><tr>
<td><tt>mxIsNumeric</tt></td><td>Function that returns true for numeric matrices.</td>

</tr><tr>
<td><tt>mxIsSparse</tt></td><td>Function that returns true for sparse matrices.</td>        
</tr><tr>
<td><tt>mxIsString</tt></td><td>Function that returns true for string matrices.</td>         
</tr><tr>
<td><tt>mxSetIr</tt></td><td>Function to set the pointer to the <tt>ir</tt> vector of a       
                <br>sparse matrix.</td>                                          
</tr><tr>
<td><tt>mxSetJc</tt></td><td>Function to set the pointer to the <tt>jc</tt> vector of a       
                <br>sparse matrix.</td>                                          
</tr><tr>
<td><tt>mxSetM</tt></td><td>Function to set the number of rows of a matrix.</td>         
</tr><tr>
<td><tt>mxSetN</tt></td><td>Function to set the number of columns of a matrix.</td>      
</tr><tr>
<td><tt>mxSetName</tt></td><td>Function to set the name of a matrix.</td>                   
</tr><tr>
<td><tt>mxSetNzmax</tt></td><td>Function to set the maximum number of nonzero           
                   <br>elements in sparse matrix.                              
</td></tr><tr>
<td><tt>mxSetPi</tt></td><td>Function to set the pointer to the imaginary part of    
                <br>a matrix.</td>                                               
</tr><tr>
<td><tt>mxSetPr</tt></td><td>Function to set the pointer to the real part of a       
                <br>matrix.</td>                                                 
</tr></tbody></table>
</center>

<p>


</p><h2>
<b>
<a name="RTFToC23">Frequently
Asked Questions (FAQ) about MEX-files
</a></b>
</h2>


<h2>
<b>
<a name="RTFToC24">Question</a></b>
</h2>

<p>
What do the following error messages mean (compiling with Metaware High C 3.01)?
</p><p>

</p><ul><pre>error: multiple entry points record in module "init".
error: duplicate definition of symbol "_unlink"
error: undefined symbol "main" in module "init"</pre></ul><br>


<h2>
<b>
<a name="RTFToC25">Answer
</a></b>
</h2>

<p>
Errors such as the ones above, that have to do with entry points and
initialization, often occur due to slight differences between the compiler
being used and the compilers that are officially supported by The MathWorks.
Despite the error message, many times a working MEX-file is created.  If a
MEX-file is created after getting these error messages, try running the
MEX-file to see if it works correctly.  If it does, ignore the error message.
</p><p>

</p><p>


</p><h2>
<b>
<a name="RTFToC26">Question</a></b>
</h2>

<p>
How can I access a global variable from inside a MEX-file?
</p><p>


</p><h2>
<b>
<a name="RTFToC27">Answer</a></b>
</h2>

<p>
In MATLAB 4.2, there is a new mex* function called <tt>mexGetGlobal</tt> that
will access global variables for you.  It uses the same calling syntax as
<tt>mexGetMatrixPtr</tt>.
</p><p>

</p><p>


</p><h2>
<b>
<a name="RTFToC28">Question</a></b>
</h2>

<p>
When creating DLL MEX-files I either get unresolved reference errors for
<tt>matOpen, matClose, matGetMatrix</tt>, and <tt>matGetDir</tt> functions, or
unresolved external <tt>sscanf</tt>.  Why?
</p><p>


</p><h2>
<b>
<a name="RTFToC29">Answer</a></b>
</h2>

<p>
MEX-files created by Microsoft's Visual C++ and Borland's C/C++ are implemented
as (16-bit) DLL functions.  Microsoft and Borland do not support the
<tt>sscanf</tt> function within DLL functions.  Since the
<tt>libmat</tt>.<tt>lib</tt> library that supplies the <tt>mat*</tt> functions
requires the <tt>sscanf</tt> function, there is no way to call <tt>mat*</tt>
functions from a DLL MEX-file.
</p><p>

</p><p>


</p><h2>
<b>
<a name="RTFToC30">Question</a></b>
</h2>

<p>
Printing with the <tt>%f, %g,</tt> and <tt>%e printf</tt> format specifiers
within DLL functions do not appear to work.  Why?
</p><p>


</p><h2>
<b>
<a name="RTFToC31">Answer</a></b>
</h2>

<p>
Microsoft and Borland do not support the <tt>%f, %g</tt>, and <tt>%e</tt>
format specifiers in DLL functions. 
</p><p>

</p><p>

</p><p>

</p><p>

</p><p>

</p><p>
</p><hr noshade="noshade">
<center>
(c) Copyright 1996 by The MathWorks, Inc.
</center>
<hr noshade="noshade">
<p>
</p><center>
<pre><a href="http://web.ccr.jussieu.fr/ccr/Documentation/Calcul/matlab5v11/docs/00001/00149.htm"><img src="mex_tutorial_files/0014a.gif" border="0"></a><a href="http://web.ccr.jussieu.fr/ccr/Documentation/Calcul/matlab5v11/docs/00000/00030.htm"><img src="mex_tutorial_files/0014b.gif" border="0"></a><a href="http://web.ccr.jussieu.fr/ccr/Documentation/Calcul/matlab5v11/docs/00006/00614.htm"><img src="mex_tutorial_files/00c18.gif" border="0"></a>
</pre>
<p>
</p></center></body></html>